{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 브라운더스트 공식 네이버카페 코스튬 이벤트 댓글 크롤러\n",
    "### (Browndust Naver Cafe Costume Event Comment Crawler)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "정진우 (Jinwoo Chung) /// `contact : chungjinwoo5d [at] naver.com`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 필요한 패키지 가져오기 (Importing Required Libraries)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from selenium import webdriver\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "import pandas as pd\n",
    "import re\n",
    "import time"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 사용자 정의 함수 (User Defined Function)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_n_child_index(lastCounter, currentCounter):\n",
    "    # setting a local variable so that it can return a value after computation\n",
    "    nextPageChildPos = -1\n",
    "    # since comments pages are divided in sector of 10\n",
    "    currentSector = int(currentCounter/10)\n",
    "    # if less than 10 it only has 1 sector\n",
    "    if(currentSector == 0):\n",
    "        nextPageChildPos = currentCounter + 1\n",
    "    else:\n",
    "        # due to n-child usage, the next page is always +2 child away\n",
    "        nextPageChildPos = ((currentCounter%10) + 2) + 1\n",
    "    return(nextPageChildPos)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 전역변수 (Global Variables)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.DataFrame(columns=['user_ID','unit_voted'])\n",
    "dfIndexCounter = 1\n",
    "r = re.compile('.*\\/.*') # this format is instructed in the event article (i.e. user ID / unit name)\n",
    "lastIndex = int(input('Last Comment Page : '))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> 직접 댓글 페이지 개수 입력 해야합니다 (따로 정의 함수 만들려 생각을 했지만, 이게 제일 단순하며 깔끔했습니다)\n",
    "\n",
    "> For the last page of the comment, user needs to input the value (I've thought about creating a user defined function to get the last page of the comment, but this was the simple and clean way to do it)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 크롤링 시작! (Crawling Start!)\n",
    "\n",
    "셀레늄 크롬으로 크롤링 합니다 (Using Selenium Chrome to Crawl)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('\\n')\n",
    "print('----------------------------------------------------------')\n",
    "print('|                   Crawling Start...                    |')\n",
    "print('----------------------------------------------------------')\n",
    "\n",
    "\n",
    "# using chrome as webdriver\n",
    "driver = webdriver.Chrome()\n",
    "\n",
    "# going into cafe's article to crawl (this is a direct link to the event page for costume)\n",
    "driver.get('http://cafe.naver.com/browndust/ArticleRead.nhn?clubid=28708849&menuid=16&articleid=217084')\n",
    "time.sleep(3) # need to give some time due to load\n",
    "driver.switch_to_frame('cafe_main')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> time.sleep 대신 다른방법을 해봤지만, 에러가 자주나서 일단 제일 무식한 방법을 사용하게 됬습니다 (**주위** 인터넷이 느리면 여기서 에러 납니다, 그럴 경우에 time.sleep시간을 늘리셔야 합니다)\n",
    "\n",
    "> I've tried other methods than time.sleep, but it kept giving inconsistent errors, so in the end used the most primitive method (**warning** if you internet is slow, you need to increase the time for time.sleep)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "이벤트글이 준비되었으니 인제 댓글 크롤링 시작합니다 (Since the event article is ready, starting comment crwaling)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for pageIndex in range(0, lastIndex):\n",
    "    # 다음 페이지 준비 기달리기\n",
    "    # Waiting for the next page to be ready\n",
    "    time.sleep(3)\n",
    "    # *** 1. 아래 추가 설명 있습니다 (There is additional elaboration for this below) ***\n",
    "    # 댓글 가져오기\n",
    "    # getting comments\n",
    "    commentList = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, '#cmt_list')))\n",
    "    # /n으로 string 나눕니다\n",
    "    # making a by separating with /n \n",
    "    splitCommentList = (commentList.text).split('\\n')\n",
    "    # 이벤트에서 댓글 투표 유형을 '/'로 나눔으로 '/'있는 텍스트를 가져옵니다 (regex 사용합니다)\n",
    "    # getting elements that includes '/' (this was the format for official voting)\n",
    "    splitCommentList = list(filter(r.match, splitCommentList))\n",
    "\n",
    "    # 각각 댓글 텍스트 parsing\n",
    "    # parsing for every legitimate comment\n",
    "    for elements in splitCommentList:\n",
    "        # 유형에 맞춰서 유저계정과 유저투표용병을 나눕니다\n",
    "        # the elements looks like 'userID / unit name'\n",
    "        splitElement = elements.split('/')\n",
    "        # 유저마다 '/'로 나눌때 여백을 넣는 분들이 있어서 여백 다 없애는 과정\n",
    "        # some users included blank spaces and some users didn't, so removing all blank spaces\n",
    "        userID = splitElement[0].replace(' ','')\n",
    "        unitVoted = splitElement[1].replace(' ','')\n",
    "        # 필요한 정보 추출 후 데이터프레임으로 넣기 (append도 가능하지만, concat이 약간 더 빨라서 concat사용했습니다)\n",
    "        # concatenating dataframe (concat is slightly faster than append)\n",
    "        data = pd.DataFrame({'user_ID': userID, 'unit_voted': unitVoted}, index=[dfIndexCounter])\n",
    "        df = pd.concat([df,data])\n",
    "        # 데이터프레임 인덱스 카운터로 넣어서 직접 1증가 시킵니다\n",
    "        # incrementing dataframe index counter (global var)\n",
    "        dfIndexCounter += 1\n",
    "    \n",
    "    print('comment Page ' + str(pageIndex+1) + ' complete...')\n",
    "    \n",
    "    # 인제 현재 페이지 크롤링 완료되어서, 다음페이지 준비하는 과정입니다\n",
    "    # Current page crawling is complete, so preparing next comment page\n",
    "    if(pageIndex != (lastIndex - 1)):\n",
    "        # 다음 페이지 가기전에 준비 과정\n",
    "        # Preparing to go to next comment page\n",
    "        nextPageChildPos = get_n_child_index(lastIndex, pageIndex)\n",
    "        nextPageXPath = '//*[@id=\"cmt_paginate\"]/a[' + str(nextPageChildPos) + ']'\n",
    "        nextPageCrawl = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, nextPageXPath)))\n",
    "        # *** 2. 아래 추가 설명 있습니다 (There is additional elaboration for this below) ***\n",
    "        # 다음 페이지 가기\n",
    "        # going to the next comment page\n",
    "        nextPageCrawl.send_keys(webdriver.common.keys.Keys.SPACE)\n",
    "        nextPageCrawl.click()\n",
    "\n",
    "print('\\n')\n",
    "print('----------------------------------------------------------')\n",
    "print('|                   Crawling Complete                    |')\n",
    "print('----------------------------------------------------------')\n",
    "print('\\n')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> **1. WebDriverWait를 사용하는데, 왜 time.sleep이 필요한가?**\n",
    "\n",
    "> 지금 현재 페이지와 다음페이지 xPath가 같아서, 만약 time.sleep을 안넣으면, 다음 페이지 가기전에 현재 페이지 에서 확인하게 됩니다. xPath가 같아서, 기달리지 않고 바로 실행하려다가 에러나서, time.sleep를 추가하게 되었습니다.\n",
    "\n",
    "> **2. click만 하면 되는데, 왜 send_keys까지 필요한가?**\n",
    "\n",
    "> 이건 확실히 왜 바로 click하면 에러가 안뜨는데 인터넷에서 다른 유사한 문제를 읽어보니, 현재 화면이 element에 없으면 에러가 나는 경우가 있다고 합니다. 그래서 send_keys를 사용해서 지금 화면을 다음페이지 가는 element에 고정 후 click을 하는겁니다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> **1. Why do you need time.sleep when you're already using WebDriverWait?**\n",
    "\n",
    "> The xPath for current comment page and the next comment page are the same, so before it goes on to the next comment page, it checks xPath for current comment page (which will return True and continue that results as an error). So in order to wait for not checking for xPath in the current page, added time.sleep.\n",
    "\n",
    "> **2. Why do you need send_keys, when you only need to do click?**\n",
    "\n",
    "> If the clicking element is not currently viewed on the browser (physically), it returns an error. I've googled about this problem, and other people also had this problem. So, the send_keys will scroll the browser to actually see the element that's about to be clicked, which solves the error."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 데이터프레임 csv로 수출 (Exporting Dataframe as csv file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.to_csv('~/Desktop/browndust-costume-event-crawled-comment.csv', sep=',', encoding='utf-8')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
